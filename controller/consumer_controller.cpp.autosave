/************************************************************************
* @Copyright: 2023-2024
* @FileName:
* @Description: Open source mediasoup C++ controller library
* @Version: 1.0.0
* @Author: Jackie Ou
* @CreateTime: 2023-10-30
*************************************************************************/

#include "consumer_controller.h"
#include "srv_logger.h"
#include "channel.h"

#include "FBS/common.h"
#include "FBS/request.h"
#include "FBS/transport.h"
#include "FBS/rtpStream.h"
#include "FBS/rtxStream.h"
#include "FBS/rtpParameters.h"

namespace srv {

ConsumerController::ConsumerController(const ConsumerInternal& internal,
                                       const ConsumerData& data,
                                       const std::shared_ptr<Channel>& channel,
                                       const nlohmann::json& appData,
                                       bool paused,
                                       bool producerPaused,
                                       const ConsumerScore& score,
                                       const ConsumerLayers& preferredLayers)
    : _internal(internal)
    , _data(data)
    , _channel(channel)
    , _appData(appData)
    , _paused(paused)
    , _producerPaused(producerPaused)
    , _score(score)
    , _preferredLayers(preferredLayers)
    {
        SRV_LOGD("ConsumerController()");
    }

    ConsumerController::~ConsumerController()
    {
        SRV_LOGD("~ConsumerController()");
    }

    void ConsumerController::init()
    {
        SRV_LOGD("init()");
        handleWorkerNotifications();
    }

    void ConsumerController::destroy()
    {
        SRV_LOGD("destroy()");
    }

    void ConsumerController::close()
    {
        if (_closed) {
            return;
        }
        
        SRV_LOGD("close()");

        _closed = true;

        // Remove notification subscriptions.
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        channel->notificationSignal.disconnect(shared_from_this());
        
        auto requestOffset = FBS::Transport::CreateCloseConsumerRequestDirect(channel->builder(), _internal.consumerId.c_str());

        channel->request(FBS::Request::Method::TRANSPORT_CLOSE_CONSUMER, FBS::Request::Body::Transport_CloseConsumerRequest, requestOffset, _internal.transportId);
        
        this->closeSignal();
    }

    void ConsumerController::onTransportClosed()
    {
        if (_closed) {
            return;
        }
        
        SRV_LOGD("onTransportClosed()");
        
        _closed = true;

        // Remove notification subscriptions.
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        channel->notificationSignal.disconnect(shared_from_this());
        
        this->transportCloseSignal();
        
        this->closeSignal();
    }

    std::shared_ptr<ConsumerDump> ConsumerController::dump()
    {
        SRV_LOGD("dump()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return nullptr;
        }
        
        flatbuffers::Offset<void> bodyOffset;
        auto data = channel->request(FBS::Request::Method::CONSUMER_DUMP, FBS::Request::Body::NONE, bodyOffset, _internal.consumerId);
        
        auto message = FBS::Message::GetMessage(data.data());
        
        auto response = message->data_as_Response();
        
        auto dumpResponse = response->body_as_Consumer_DumpResponse();
        
        return parseConsumerDumpResponse(dumpResponse);
    }

    std::shared_ptr<ConsumerStat> ConsumerController::getStats()
    {
        SRV_LOGD("getStats()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return std::vector<ConsumerStat>();
        }
        
        return channel->request("consumer.getStats", _internal.consumerId, "{}");
    }

    void ConsumerController::pause()
    {
        SRV_LOGD("pause()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }

        channel->request("consumer.pause", _internal.consumerId, "{}");
        
        bool wasPaused = _paused;

        _paused = true;

        // Emit observer event.
        if (!wasPaused && !_producerPaused) {
            this->pauseSignal();
        }
    }

    void ConsumerController::resume()
    {
        SRV_LOGD("resume()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }

        channel->request("consumer.resume", _internal.consumerId, "{}");

        bool wasPaused = _paused;

        _paused = false;

        // Emit observer event.
        if (wasPaused && !_producerPaused) {
            this->resumeSignal();
        }
    }

    void ConsumerController::setPreferredLayers(const ConsumerLayers& layers)
    {
        SRV_LOGD("setPreferredLayers()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        
        nlohmann::json reqData;
        reqData["spatialLayer"] = layers.spatialLayer;
        reqData["temporalLayer"] = layers.temporalLayer;
        
        nlohmann::json data = channel->request("consumer.setPreferredLayers", _internal.consumerId, reqData.dump());
        
        if (data.is_object() && data.find("spatialLayer") != data.end() && data.find("temporalLayer") != data.end()) {
            _preferredLayers = data;
        }
        else {
            _preferredLayers.spatialLayer = 0;
            _preferredLayers.temporalLayer = 0;
        }
    }

    void ConsumerController::setPriority(int32_t priority)
    {
        SRV_LOGD("setPriority()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        
        nlohmann::json reqData;
        reqData["priority"] = priority;
        
        nlohmann::json data = channel->request("consumer.setPriority", _internal.consumerId, reqData.dump());
        
        if (data.is_object() && data.find("priority") != data.end()) {
            _priority = data["priority"];
        }
        else {
            _priority = 1;
        }
    }

    void ConsumerController::unsetPriority()
    {
        SRV_LOGD("unsetPriority()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        
        nlohmann::json reqData;
        reqData["priority"] = 1;
        
        nlohmann::json data = channel->request("consumer.setPriority", _internal.consumerId, reqData.dump());
        
        if (data.is_object() && data.find("priority") != data.end()) {
            _priority = data["priority"];
        }
        else {
            _priority = 1;
        }
    }

    void ConsumerController::requestKeyFrame()
    {
        SRV_LOGD("requestKeyFrame()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        
        channel->request("consumer.requestKeyFrame", _internal.consumerId, "{}");
    }

    // types = 'rtp' | 'keyframe' | 'nack' | 'pli' | 'fir';
    void ConsumerController::enableTraceEvent(const std::vector<std::string>& types)
    {
        SRV_LOGD("enableTraceEvent()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        
        nlohmann::json reqData = nlohmann::json::array();
        for (const auto& type : types) {
            reqData.emplace_back(type);
        }
        
        nlohmann::json data = channel->request("consumer.enableTraceEvent", _internal.consumerId, reqData.dump());
    }

    void ConsumerController::handleWorkerNotifications()
    {
        SRV_LOGD("handleWorkerNotifications()");
        
        auto channel = _channel.lock();
        if (!channel) {
            return;
        }
        channel->notificationSignal.connect(&ConsumerController::onChannel, shared_from_this());
    }

    void ConsumerController::onChannel(const std::string& targetId, FBS::Notification::Event event, const std::vector<uint8_t>& data)
    {
        if (targetId != _internal.consumerId) {
            return;
        }
        
        if (event == "producerclose") {
            if (_closed) {
                return;
            }
            _closed = true;
            
            auto channel = _channel.lock();
            if (!channel) {
                return;
            }
            channel->notificationSignal.disconnect(shared_from_this());
            
            this->producerCloseSignal();
            
            this->closeSignal();
        }
        else if (event == "producerpause") {
            if (_producerPaused) {
                return;
            }
            
            _producerPaused = true;
            
            this->producerPauseSignal();
            
            if (!_paused) {
                this->pauseSignal();
            }
        }
        else if (event == "producerresume") {
            if (!_producerPaused) {
                return;
            }
            
            _producerPaused = false;
            
            this->producerResumeSignal();
            
            if (!_paused) {
                this->resumeSignal();
            }
        }
        else if (event == "score") {
            auto js = nlohmann::json::parse(data);
            if (js.is_object()) {
                ConsumerScore score = js;
                this->scoreSignal(score);
            }
        }
        else if (event == "layerschange") {
            auto js = nlohmann::json::parse(data);
            if (js.is_object()) {
                ConsumerLayers layers = js;
                _currentLayers = layers;
                this->layersChangeSignal(layers);
            }
        }
        else if (event == "trace") {
            auto js = nlohmann::json::parse(data);
            if (js.is_object()) {
                ConsumerTraceEventData eventData = js;
                this->traceSignal(eventData);
            }
        }
        else {
            SRV_LOGD("ignoring unknown event %s", event.c_str());
        }
    }

    std::shared_ptr<ConsumerDump> ConsumerController::parseConsumerDumpResponse(const FBS::Consumer::DumpResponse* response)
    {
        std::shared_ptr<BaseConsumerDump> consumerDump;
        
        auto type = response->data()->base()->type();
        switch(type) {
            case FBS::RtpParameters::Type::SIMPLE:
                consumerDump = parseSimpleConsumerDump(response->data());
                break;
            case FBS::RtpParameters::Type::SIMULCAST:
                consumerDump = parseSimulcastConsumerDump(response->data());
                break;
            case FBS::RtpParameters::Type::SVC:
                consumerDump = parseSvcConsumerDump(response->data());
                break;
            case FBS::RtpParameters::Type::PIPE:
                consumerDump = parsePipeConsumerDump(response->data());
                break;
            default:
                break;
        }
        
        return consumerDump;
    }

    std::shared_ptr<BaseConsumerDump> ConsumerController::parseBaseConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump)
    {
        auto dump = std::make_shared<BaseConsumerDump>();
        dump->id = consumerDump->base()->id()->str();
        dump->producerId = consumerDump->base()->producerId()->str();
        dump->kind = consumerDump->base()->kind() == FBS::RtpParameters::MediaKind::VIDEO ? "video" : "audio";
        
        // RtpParameters rtpParameters;
        {
            dump->rtpParameters.mid = consumerDump->base()->rtpParameters()->mid()->str();

            std::vector<RtpCodecParameters> codecs;
            const auto* codecsFBS = consumerDump->base()->rtpParameters()->codecs();
            for (const auto& codec : *codecsFBS) {
                RtpCodecParameters parameters;
                {
                    parameters.mimeType = codec->mimeType()->str();
                    
                    parameters.payloadType = codec->payloadType();
                    
                    parameters.clockRate = codec->clockRate();

                    parameterschannels =;

                    /**
                     * Codec-specific parameters available for signaling. Some parameters (such
                     * as 'packetization-mode' and 'profile-level-id' in H264 or 'profile-id' in
                     * VP9) are critical for codec matching.
                     */
                    Parameters parameters;

                    /**
                     * Transport layer and codec-specific feedback messages for this codec.
                     */
                    std::vector<RtcpFeedback> rtcpFeedback;
                }
//                parameters.parameters
                dump->rtpParameters->codecs.emplace_back(parameters);
            }

            /**
             * RTP header extensions in use.
             */
            std::vector<RtpHeaderExtensionParameters> headerExtensions;

            /**
             * Transmitted RTP streams and their settings.
             */
            std::vector<RtpEncodingParameters> encodings;

            /**
             * Parameters used for RTCP.
             */
            RtcpParameters rtcp;
        }

        // std::vector<RtpEncodingParameters> consumableRtpEncodings;
        // std::vector<uint8_t> supportedCodecPayloadTypes;
        // std::vector<std::string> traceEventTypes;
        // bool paused;
        // bool producerPaused;
        // int32_t priority;
    }

    std::shared_ptr<SimpleConsumerDump> ConsumerController::parseSimpleConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump)
    {
        
    }

    std::shared_ptr<SimulcastConsumerDump> ConsumerController::parseSimulcastConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump)
    {
        
    }

    std::shared_ptr<SvcConsumerDump> ConsumerController::parseSvcConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump)
    {
        
    }

    std::shared_ptr< PipeConsumerDump> ConsumerController::parsePipeConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump)
    {
        
    }

}


namespace srv
{
    void to_json(nlohmann::json& j, const ConsumerLayers& st)
    {
        j["spatialLayer"] = st.spatialLayer;
        j["temporalLayer"] = st.temporalLayer;
    }

    void from_json(const nlohmann::json& j, ConsumerLayers& st)
    {
        if (j.contains("spatialLayer")) {
            j.at("spatialLayer").get_to(st.spatialLayer);
        }
        if (j.contains("temporalLayer")) {
            j.at("temporalLayer").get_to(st.temporalLayer);
        }
    }

    void to_json(nlohmann::json& j, const ConsumerScore& st)
    {
        j["score"] = st.score;
        j["producerScore"] = st.producerScore;
        j["producerScores"] = st.producerScores;
    }

    void from_json(const nlohmann::json& j, ConsumerScore& st)
    {
        if (j.contains("score")) {
            j.at("score").get_to(st.score);
        }
        if (j.contains("producerScore")) {
            j.at("producerScore").get_to(st.producerScore);
        }
        if (j.contains("producerScores")) {
            j.at("producerScores").get_to(st.producerScores);
        }
    }

    void to_json(nlohmann::json& j, const ConsumerTraceEventData& st)
    {
        j["type"] = st.type;
        j["timestamp"] = st.timestamp;
        j["direction"] = st.direction;
        j["info"] = st.info;
    }

    void from_json(const nlohmann::json& j, ConsumerTraceEventData& st)
    {
        if (j.contains("type")) {
            j.at("type").get_to(st.type);
        }
        if (j.contains("timestamp")) {
            j.at("timestamp").get_to(st.timestamp);
        }
        if (j.contains("direction")) {
            j.at("direction").get_to(st.direction);
        }
        if (j.contains("info")) {
            j.at("info").get_to(st.info);
        }
    }

    void to_json(nlohmann::json& j, const ConsumerStat& st)
    {
        j["type"] = st.type;
        j["timestamp"] = st.timestamp;
        j["ssrc"] = st.ssrc;
        j["rtxSsrc"] = st.rtxSsrc;
        j["kind"] = st.kind;

        j["mimeType"] = st.mimeType;
        j["packetsLost"] = st.packetsLost;
        j["fractionLost"] = st.fractionLost;
        j["packetsDiscarded"] = st.packetsDiscarded;
        j["packetsRetransmitted"] = st.packetsRetransmitted;

        j["packetsRepaired"] = st.packetsRepaired;
        j["nackCount"] = st.nackCount;
        j["nackPacketCount"] = st.nackPacketCount;
        j["pliCount"] = st.pliCount;
        j["firCount"] = st.firCount;

        j["score"] = st.score;
        j["packetCount"] = st.packetCount;
        j["byteCount"] = st.byteCount;
        j["bitrate"] = st.bitrate;
        j["roundTripTime"] = st.roundTripTime;
    }

    void from_json(const nlohmann::json& j, ConsumerStat& st)
    {
        if (j.contains("type")) {
            j.at("type").get_to(st.type);
        }
        if (j.contains("timestamp")) {
            j.at("timestamp").get_to(st.timestamp);
        }
        if (j.contains("ssrc")) {
            j.at("ssrc").get_to(st.ssrc);
        }
        if (j.contains("rtxSsrc")) {
            j.at("rtxSsrc").get_to(st.rtxSsrc);
        }
        if (j.contains("kind")) {
            j.at("kind").get_to(st.kind);
        }
        
        if (j.contains("mimeType")) {
            j.at("mimeType").get_to(st.mimeType);
        }
        if (j.contains("packetsLost")) {
            j.at("packetsLost").get_to(st.packetsLost);
        }
        if (j.contains("fractionLost")) {
            j.at("fractionLost").get_to(st.fractionLost);
        }
        if (j.contains("packetsDiscarded")) {
            j.at("packetsDiscarded").get_to(st.packetsDiscarded);
        }
        if (j.contains("packetsRetransmitted")) {
            j.at("packetsRetransmitted").get_to(st.packetsRetransmitted);
        }
        
        if (j.contains("packetsRepaired")) {
            j.at("packetsRepaired").get_to(st.packetsRepaired);
        }
        if (j.contains("nackCount")) {
            j.at("nackCount").get_to(st.nackCount);
        }
        if (j.contains("nackPacketCount")) {
            j.at("nackPacketCount").get_to(st.nackPacketCount);
        }
        if (j.contains("pliCount")) {
            j.at("pliCount").get_to(st.pliCount);
        }
        if (j.contains("firCount")) {
            j.at("firCount").get_to(st.firCount);
        }
        
        if (j.contains("score")) {
            j.at("score").get_to(st.score);
        }
        if (j.contains("packetCount")) {
            j.at("packetCount").get_to(st.packetCount);
        }
        if (j.contains("byteCount")) {
            j.at("byteCount").get_to(st.byteCount);
        }
        if (j.contains("bitrate")) {
            j.at("bitrate").get_to(st.bitrate);
        }
        if (j.contains("roundTripTime")) {
            j.at("roundTripTime").get_to(st.roundTripTime);
        }
    }

}

/************************************************************************
* @Copyright: 2023-2024
* @FileName:
* @Description: Open source mediasoup C++ controller library
* @Version: 1.0.0
* @Author: Jackie Ou
* @CreateTime: 2023-10-30
*************************************************************************/

#pragma once

#include <memory>
#include <vector>
#include <atomic>
#include <string>
#include <unordered_map>
#include "nlohmann/json.hpp"
#include "sigslot/signal.hpp"
#include "types.h"
#include "rtp_stream.h"
#include "rtp_parameters.h"
#include "FBS/notification.h"
#include "FBS/consumer.h"

namespace srv {

    struct ConsumerLayers
    {
        /**
         * The spatial layer index (from 0 to N).
         */
        int32_t spatialLayer;

        /**
         * The temporal layer index (from 0 to N).
         */
        int32_t temporalLayer;
    };

    struct ConsumerOptions
    {
        /**
         * The id of the Producer to consume.
         */
        std::string producerId;

        /**
         * RTP capabilities of the consuming endpoint.
         */
        RtpCapabilities rtpCapabilities;

        /**
         * Whether the Consumer must start in paused mode. Default false.
         *
         * When creating a video Consumer, it's recommended to set paused to true,
         * then transmit the Consumer parameters to the consuming endpoint and, once
         * the consuming endpoint has created its local side Consumer, unpause the
         * server side Consumer using the resume() method. This is an optimization
         * to make it possible for the consuming endpoint to render the video as far
         * as possible. If the server side Consumer was created with paused: false,
         * mediasoup will immediately request a key frame to the remote Producer and
         * suych a key frame may reach the consuming endpoint even before it's ready
         * to consume it, generating “black” video until the device requests a keyframe
         * by itself.
         */
        bool paused = false;

        /**
         * The MID for the Consumer. If not specified, a sequentially growing
         * number will be assigned.
         */
        std::string mid;

        /**
         * Preferred spatial and temporal layer for simulcast or SVC media sources.
         * If unset, the highest ones are selected.
         */
        ConsumerLayers preferredLayers;

        /**
         * Whether this Consumer should enable RTP retransmissions, storing sent RTP
         * and processing the incoming RTCP NACK from the remote Consumer. If not set
         * it's true by default for video codecs and false for audio codecs. If set
         * to true, NACK will be enabled if both endpoints (mediasoup and the remote
         * Consumer) support NACK for this codec. When it comes to audio codecs, just
         * OPUS supports NACK.
         */
        bool enableRtx = true;

        /**
         * Whether this Consumer should ignore DTX packets (only valid for Opus codec).
         * If set, DTX packets are not forwarded to the remote Consumer.
         */
        bool ignoreDtx = false;

        /**
         * Whether this Consumer should consume all RTP streams generated by the
         * Producer.
         */
        bool pipe = false;

        /**
         * Custom application data.
         */
        nlohmann::json appData;
    };

    /**
     * Valid types for 'trace' event.
     */
    //export type ConsumerTraceEventType = 'rtp' | 'keyframe' | 'nack' | 'pli' | 'fir';

    /**
     * 'trace' event data.
     */
    struct ConsumerTraceEventData
    {
        /**
         * Trace type.
         * options:  'rtp' | 'keyframe' | 'nack' | 'pli' | 'fir'
         */
        std::string type;

        /**
         * Event timestamp.
         */
        int64_t timestamp;

        /**
         * Event direction.
         * options: 'in' | 'out'
         */
        std::string direction;

        /**
         * Per type information.
         */
        std::shared_ptr<TraceInfo> info;
    };

    struct ConsumerScore
    {
        /**
         * The score of the RTP stream of the consumer.
         */
        int32_t score;

        /**
         * The score of the currently selected RTP stream of the producer.
         */
        int32_t producerScore;

        /**
         * The scores of all RTP streams in the producer ordered by encoding (just
         * useful when the producer uses simulcast).
         */
        std::vector<int32_t> producerScores;
    };

    using ConsumerStat = RtpStreamSendStats;

    struct ConsumerInternal
    {
        std::string routerId;
        std::string transportId;
        std::string consumerId;
    };

    struct ConsumerData
    {
        std::string producerId;
        
        // options: 'audio' | 'video'
        std::string kind;
        
        RtpParameters rtpParameters;
        
        // options: 'simple' | 'simulcast' | 'svc' | 'pipe'
        std::string type;
    };

    struct BaseConsumerDump
    {
        std::string id;
        std::string producerId;
        std::string kind;
        RtpParameters rtpParameters;
        std::vector<RtpEncodingParameters> consumableRtpEncodings;
        std::vector<uint8_t> supportedCodecPayloadTypes;
        std::vector<std::string> traceEventTypes;
        bool paused;
        bool producerPaused;
        int32_t priority;
    };

    struct SimpleConsumerDump : BaseConsumerDump
    {
        std::string type;
        RtpStreamDump rtpStream;
    };

    struct SimulcastConsumerDump : BaseConsumerDump
    {
        std::string type;
        RtpStreamDump rtpStream;
        int16_t preferredSpatialLayer;
        int16_t targetSpatialLayer;
        int16_t currentSpatialLayer;
        int16_t preferredTemporalLayer;
        int16_t targetTemporalLayer;
        int16_t currentTemporalLayer;
    };

    using SvcConsumerDump = SimulcastConsumerDump;

    struct PipeConsumerDump : BaseConsumerDump
    {
        std::string type;
        std::vector<RtpStreamDump> rtpStreams;
    };

    using ConsumerDump = BaseConsumerDump;

    class Channel;
    class PayloadChannel;

    class ConsumerController : public std::enable_shared_from_this<ConsumerController>
    {
    public:
        ConsumerController(const ConsumerInternal& internal,
                           const ConsumerData& data,
                           const std::shared_ptr<Channel>& channel,
                           const nlohmann::json& appData,
                           bool paused,
                           bool producerPaused,
                           const ConsumerScore& score,
                           const ConsumerLayers& preferredLayers);
        
        virtual ~ConsumerController();
        
        void init();
        
        void destroy();
        
        const std::string& id() { return _internal.consumerId; }
        
        const std::string& producerId() { return _data.producerId; }

        const std::string& kind() { return _data.kind; }

        const RtpParameters& rtpParameters() { return _data.rtpParameters; }

        const std::string& type() { return _data.type; }

        bool paused() { return _paused; }

        bool producerPaused() { return _producerPaused; }

        int32_t priority() { return _priority; }

        const ConsumerScore& score() { return _score; }

        const ConsumerLayers& preferredLayers() { return _preferredLayers; }

        const ConsumerLayers& currentLayers() { return _currentLayers; }
        
        bool closed() { return _closed; }
        
        void setAppData(const nlohmann::json& data) { _appData = data; }
        
        const nlohmann::json& appData() { return _appData; }
        
        void close();
        
        void onTransportClosed();
        
        std::shared_ptr<ConsumerDump> dump();
        
        std::vector<std::shared_ptr<ConsumerStat>> getStats();
        
        void pause();
        
        void resume();
        
        void setPreferredLayers(const ConsumerLayers& layers);
        
        void setPriority(int32_t priority);

        void unsetPriority();

        void requestKeyFrame();

        // types = 'rtp' | 'keyframe' | 'nack' | 'pli' | 'fir';
        void enableTraceEvent(const std::vector<std::string>& types);
        
    private:
        void handleWorkerNotifications();

        void onChannel(const std::string& targetId, FBS::Notification::Event event, const std::vector<uint8_t>& data);
        
        std::shared_ptr<ConsumerDump> parseConsumerDumpResponse(const FBS::Consumer::DumpResponse* response);
        
        std::shared_ptr<BaseConsumerDump> parseBaseConsumerDump(const FBS::Consumer::BaseConsumerDump* data);

        std::shared_ptr<SimpleConsumerDump> parseSimpleConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump);

        std::shared_ptr<SimulcastConsumerDump> parseSimulcastConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump);

        std::shared_ptr<SvcConsumerDump> parseSvcConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump);

        std::shared_ptr<PipeConsumerDump> parsePipeConsumerDump(const FBS::Consumer::ConsumerDump* consumerDump);
        
        std::shared_ptr<ConsumerTraceEventData> parseTraceEventData(const FBS::Consumer::TraceNotification* trace);
        
        std::shared_ptr<ConsumerLayers>  parseConsumerLayers(const FBS::Consumer::ConsumerLayers* data);

        std::vector<std::shared_ptr<ConsumerStat>> parseConsumerStats(const FBS::Consumer::GetStatsResponse* binary);
        
    public:
        // signals
        sigslot::signal<> transportCloseSignal;
        
        sigslot::signal<> producerCloseSignal;
        
        sigslot::signal<> producerPauseSignal;
        
        sigslot::signal<> producerResumeSignal;
        
        sigslot::signal<const ConsumerScore&> scoreSignal;
        
        sigslot::signal<const ConsumerLayers&> layersChangeSignal;
        
        sigslot::signal<const ConsumerTraceEventData&> traceSignal;
        
        sigslot::signal<const std::vector<uint8_t>&> rtpSignal;
        
        sigslot::signal<> closeSignal;
        
        sigslot::signal<> pauseSignal;
        
        sigslot::signal<> resumeSignal;
        
    private:
        // Internal data.
        ConsumerInternal _internal;

        // Consumer data.
        ConsumerData _data;

        // Channel instance.
        std::weak_ptr<Channel> _channel;

        // Closed flag.
        std::atomic_bool _closed { false };

        // Custom app data.
        nlohmann::json _appData;

        // Paused flag.
        std::atomic_bool _paused { false };

        // Associated Producer paused flag.
        std::atomic_bool _producerPaused { false };

        // Current priority.
        int32_t _priority = 1;

        // Current score.
        ConsumerScore _score;

        // Preferred layers.
        ConsumerLayers _preferredLayers;

        // Curent layers.
        ConsumerLayers _currentLayers;
    };

}

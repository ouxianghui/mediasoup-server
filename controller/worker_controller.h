/************************************************************************
* @Copyright: 2023-2024
* @FileName:
* @Description: Open source mediasoup C++ controller library
* @Version: 1.0.0
* @Author: Jackie Ou
* @CreateTime: 2023-10-30
*************************************************************************/

#pragma once

#include <memory>
#include <tuple>
#include <atomic>
#include <unordered_set>
#include <mutex>
#include "nlohmann/json.hpp"
#include "sigslot/signal.hpp"
#include "types.h"
#include "transport_controller.h"
#include "router_controller.h"
#include "webrtc_server_controller.h"

namespace srv {
    
    class Channel;
    class PayloadChannel;

    struct WorkerSettings
    {
        /**
         * Logging level for logs generated by the media worker subprocesses (check
         * the Debugging documentation). Valid values are 'debug', 'warn', 'error' and
         * 'none'. Default 'error'.
         */
        std::string logLevel = "debug";
        
        /**
         * Log tags for debugging. Check the meaning of each available tag in the
         * Debugging documentation.
         *  options: 'info' | 'ice' | 'dtls' | 'rtp' | 'srtp' | 'rtcp' | 'rtx' | 'bwe' | 'score' | 'simulcast' | 'svc' | 'sctp' | 'message';
         */
        std::vector<std::string> logTags;
        
        /**
         * Minimun RTC port for ICE, DTLS, RTP, etc. Default 10000.
         */
        int32_t rtcMinPort = 10000;
        
        /**
         * Maximum RTC port for ICE, DTLS, RTP, etc. Default 59999.
         */
        int32_t rtcMaxPort = 59999;
        
        /**
         * Path to the DTLS public certificate file in PEM format. If unset, a
         * certificate is dynamically created.
         */
        std::string dtlsCertificateFile;
        
        /**
         * Path to the DTLS certificate private key file in PEM format. If unset, a
         * certificate is dynamically created.
         */
        std::string dtlsPrivateKeyFile;
        
        /**
         * Field trials for libwebrtc.
         * @private
         *
         * NOTE: For advanced users only. An invalid value will make the worker crash.
         * Default value is
         * "WebRTC-Bwe-AlrLimitedBackoff/Enabled/".
         */
        std::string libwebrtcFieldTrials;
        
        /**
         * Custom application data.
         */
        nlohmann::json appData;
    };
    
    void to_json(nlohmann::json& j, const WorkerSettings& st);
    void from_json(const nlohmann::json& j, WorkerSettings& st);

    /**
    * An object with the fields of the uv_rusage_t struct.
    *
    * - http://docs.libuv.org/en/v1.x/misc.html#c.uv_rusage_t
    * - https://linux.die.net/man/2/getrusage
    */
    struct WorkerResourceUsage 
    {
        /* eslint-disable camelcase */
        
        /**
        * User CPU time used (in ms).
        */
        int64_t ru_utime = 0;
        
        /**
        * System CPU time used (in ms).
        */
        int64_t ru_stime = 0;
        
        /**
        * Maximum resident set size.
        */
        int64_t ru_maxrss = 0;
        
        /**
        * Integral shared memory size.
        */
        int64_t ru_ixrss = 0;
        
        /**
        * Integral unshared data size.
        */
        int64_t ru_idrss = 0;
        
        /**
        * Integral unshared stack size.
        */
        int64_t ru_isrss = 0;
        
        /**
        * Page reclaims (soft page faults).
        */
        int64_t ru_minflt = 0;
        
        /**
        * Page faults (hard page faults).
        */
        int64_t ru_majflt = 0;
        
        /**
        * Swaps.
        */
        int64_t ru_nswap = 0;
        
        /**
        * Block input operations.
        */
        int64_t ru_inblock = 0;
        
        /**
        * Block output operations.
        */
        int64_t ru_oublock = 0;
        
        /**
        * IPC messages sent.
        */
        int64_t ru_msgsnd = 0;
        
        /**
        * IPC messages received.
        */
        int64_t ru_msgrcv = 0;
        
        /**
        * Signals received.
        */
        int64_t ru_nsignals = 0;
        
        /**
        * Voluntary context switches.
        */
        int64_t ru_nvcsw = 0;
        
        /**
        * Involuntary context switches.
        */
        int64_t ru_nivcsw = 0;
        
        /* eslint-enable camelcase */
    };

    void to_json(nlohmann::json& j, const WorkerResourceUsage& st);
    void from_json(const nlohmann::json& j, WorkerResourceUsage& st);

    class WorkerController : public std::enable_shared_from_this<WorkerController>
    {
    public:
        WorkerController(const std::shared_ptr<WorkerSettings>& settings);
        
        ~WorkerController();
        
        void init();
        
        void destroy();
        
        void runWorker();
        
        bool closed();
        
        void setAppData(const nlohmann::json& data) { _appData = data; }
        
        std::shared_ptr<WebRtcServerController> webRtcServerController() { return !_webRtcServerControllers.empty() ? *_webRtcServerControllers.begin() : nullptr; }
        
        const nlohmann::json& appData() { return _appData; }
        
        nlohmann::json dump();
        
        std::shared_ptr<WorkerResourceUsage> getResourceUsage();
        
        void updateSettings(const std::string& logLevel, const std::vector<std::string>& logTags);
        
        std::shared_ptr<WebRtcServerController> createWebRtcServerController(const std::shared_ptr<WebRtcServerOptions>& options, const nlohmann::json& appData);
        
        std::shared_ptr<RouterController> createRouterController(const std::vector<RtpCodecCapability>& mediaCodecs, const nlohmann::json& appData);
        
    public:
        sigslot::signal<> startSignal;

        sigslot::signal<> closeSignal;
        
        sigslot::signal<std::shared_ptr<WebRtcServerController>> newWebRtcServerSignal;
        
        sigslot::signal<std::shared_ptr<RouterController>> newRouterSignal;

    private:
        std::vector<std::string> getArgs(const std::shared_ptr<WorkerSettings>& settings);
        
        void close();
        
        void onWebRtcServerClose(std::shared_ptr<WebRtcServerController> controller);
        
        void onRouterClose(std::shared_ptr<RouterController> controller);
        
        void getDump();
        
    private:
        void handleWorkerNotifications();
        
        void onChannel(const std::string& targetId, const std::string& event, const std::string& data);
        
        void onPayloadChannel(const std::string& targetId, const std::string& event, const std::string& data, const uint8_t* payload, size_t payloadLen);
        
        
    private:
        std::shared_ptr<WorkerSettings> _settings;
        
        // Channel instance.
        std::shared_ptr<Channel> _channel;

        // PayloadChannel instance.
        std::shared_ptr<PayloadChannel> _payloadChannel;

        // Closed flag.
        std::atomic_bool _closed { false };

        // Custom app data.
        nlohmann::json _appData;

        std::mutex _webRtcServersMutex;
        // WebRtcServers set.
        std::unordered_set<std::shared_ptr<WebRtcServerController>> _webRtcServerControllers;

        std::mutex _routersMutex;
        // Routers set.
        std::unordered_set<std::shared_ptr<RouterController>> _routerControllers;
        
        std::thread _thread;
    };
    
}
